# AFL Fuzzing Documentation
---

## 1. Files

* **`vuln.c`**: A minimal C program with an intentional buffer overflow.
* **`fuzzer.sh`**: A helper script to configure environment variables and launch AFL.
* **`analyze_crash.sh`**: A script to quickly inspect crash inputs generated by AFL.

---

## 2. `vuln.c`

### Purpose

* Serves as the target binary for AFL fuzzing.
* Reads input from a file into a fixed-size stack buffer.
* Calls a vulnerable function that uses `strcpy`, enabling a classic stack-based buffer overflow.

### Code Walkthrough

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

void vuln(char *input) {
  char buf[64];
  strcpy(buf, input);  // intentional overflow
}

int main(int argc, char **argv) {
  char buffer[1024];
  if (argc != 2) {
    printf("Usage: %s <input_file>\n", argv[0]);
    return 1;
  }

  int fd = open(argv[1], O_RDONLY);
  if (fd < 0) { perror("Failed to open input file"); return 1; }

  ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);
  close(fd);

  if (bytes_read <= 0) {
    printf("Failed to read input or empty file\n");
    return 1;
  }

  buffer[bytes_read] = '\0';  // Null-terminate
  vuln(buffer);

  printf("Program executed successfully\n");
  return 0;
}
```

### Vulnerability

* **Type:** Stack-based buffer overflow
* **Location:** `strcpy(buf, input);` copies up to 1023 bytes into a 64-byte buffer without bounds checking.
* **Impact:** Overwriting the return address of `vuln()` can lead to arbitrary code execution or crash detection by AFL.

### Compiling

```bash
afl-gcc -o target vuln.c -fno-stack-protector -no-pie -z execstack -O0
```

* `afl-gcc` - AFL’s wrapper around gcc that instruments your binary for fuzzing.

* `-o target` - Names the output executable “target.”

* `vuln.c` - Your C source file containing the deliberate vulnerability.

* `-fno-stack-protector` - Disables compiler-inserted stack canaries, so buffer overflows won’t be caught and aborted early.

* `-no-pie` - Turns off Position-Independent Executable generation, giving a fixed code base address (necessary for reproducible crashes).

* `-z execstack` - Marks the stack as executable, allowing shellcode execution for testing exploits.

* `-O0` - Disables optimizations so the compiler doesn’t inline or elide code you want to fuzz.

**If running into issues like slow exec/s or no crash detection, run the following:**
* Enable core dumps:
  ```bash
  echo core | sudo tee /proc/sys/kernel/core_pattern
  ```
  * Ensures a “core” file is generated on crash so AFL can detect it
* Disable ASLR:
  ```bash
  echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
  ```
  * Keeps memory layout consistent for reliable crash and performance tracking


### Reasoning

* Using `strcpy` on a fixed-size local array creates a deterministic crash scenario for fuzzing.
* Reading from a file (`open`/`read`) simplifies automated input provisioning via AFL’s `@@` placeholder.

---

## 3. `fuzzer.sh`

```bash
#!/usr/bin/env bash

# Create output directory if it doesn't exist
dkdir -p out
# Clean previous runs
rm -rf out/*

# AFL performance and stability tweaks
export AFL_SKIP_CPUFREQ=1               # Skip CPU frequency check to avoid delays on some systems
export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1  # Disable strict crash counting to focus on paths
export AFL_SKIP_BIN_CHECK=1             # Skip sanity checks on the target binary

# Optional: Enable parallel mode for multiple AFL instances
# export AFL_NO_AFFINITY=1

# Launch AFL with basic tuning
afl-fuzz -i in -o out -m none -t 1000+ -d -p fast -- ./target @@
```

### Purpose

* Automates setup and execution of AFL for reproducible fuzzing runs.
* Applies environment variables to mitigate common AFL performance and compatibility issues.

### Key Flags and Why

* `AFL_SKIP_CPUFREQ=1`:

  * **Issue:** On some systems, CPU frequency scaling causes AFL to miscalculate execution speed.
  * **Solution:** Skipping the check prevents unnecessary throttling.

* `AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1`:

  * **Issue:** AFL may exit early if it thinks crashes were missed (e.g., sanitized binaries, missing signal coverage).
  * **Solution:** Disables strict crash accounting, allowing fuzzing to continue exploring new paths.

* `AFL_SKIP_BIN_CHECK=1`:

  * **Issue:** AFL’s binary sanity checks can fail on custom-compiled or non-standard executables.
  * **Solution:** Skips these checks to allow fuzzing on any valid ELF.

* Fuzzer options:

  * `-i in`: Use `in/seed*` directory for initial test cases
  * `-o out`: Store fuzzing output and crashes here
  * `-m none`: No memory limit to prevent AFL from aborting large-input tests
  * `-t 1000+`: Per-test timeout, allowing longer execution
  * `-d`: Skip deterministic fuzzing, focusing on speed
  * `-p fast`: Use a fast power schedule for aggressive exploration

---

## 4. `analyze_crash.sh`


### Purpose

* Selects the first (or user-specified) AFL crash input
* Shows a hex dump of the first 100 bytes for quick payload inspection
* Reports the total file size in bytes

### Reasoning

* Automates repetitive `hexdump` + `stat` steps for each crash file
* Helps spot unusual byte patterns or headers at a glance
* Flags unusually large or small inputs for prioritized debugging

---

## 5. Challenges & Workarounds

1. **CPU Frequency Scaling:**

   * *Symptom:* AFL reports inconsistent execution speed and stalls.
   * *Workaround:* `export AFL_SKIP_CPUFREQ=1` disables the check.

2. **Missing Crash Accounting:**

   * *Symptom:* AFL exits with `missing crash detection` errors on sanitizing builds.
   * *Workaround:* `export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1` allows fuzzing to continue.

3. **Binary Sanity Checks:**

   * *Symptom:* AFL refuses to fuzz on a stripped or custom-compiled binary.
   * *Workaround:* `export AFL_SKIP_BIN_CHECK=1` bypasses this restriction.

4. **Deterministic vs. Fast Mode:**

   * Deterministic (`-d`) mode produces fewer unique paths on simple targets.
   * Switching to fast power schedule (`-p fast`) accelerates path discovery.

5. **Crash Analysis Overhead:**

   * Manually locating and inspecting crashes is slow.
   * Created `analyze_crash.sh` to automate file selection and initial preview.

---

# AFL Crash Analysis Pipeline Documentation

This documentation describes the crash analysis pipeline that processes AFL fuzzer crashes, organizes them by root cause, and produces a repeatable proof-of-concept exploit.

## Pipeline Components

The workflow consists of four main components:

1. **Crash Minimization** (`minimize.sh`)  
2. **Crash Triage** (`triage.py`)  
3. **PoC Generation** (`poc.py`)  
4. **Crash Summary Documentation** (generated by `pipeline.sh`)


## Component Details

### 1. Crash Minimization (`minimize.sh`)

**Purpose**: Reduce the potentially large number of AFL crash inputs to a minimal, non-redundant set.

**Functionality**:
- Takes raw AFL crashes from `out/crashes/`
- Uses `afl-cmin` to deduplicate and minimize the crashes
- Outputs minimized crashes to `out/crashes_min/`

**Usage**:
```bash
./minimize.sh [target_binary] [input_crashes_dir] [output_min_dir]
```

### 2. Crash Triage (`triage.py`)

**Purpose**: Group crashes by their root cause location in the code.

**Functionality**:
- Iterates through each file in the minimized crash directory
- Runs each crash through a debugger to capture stack traces
- Extracts key stack frames to identify crash locations
- Groups crashes that share the same root cause
- Outputs a JSON report with crash groups

**Usage**:
```bash
CRASHES_DIR="out/crashes_min" TARGET_BINARY="./target_binary" python3 triage.py
```

### 3. PoC Generation (`poc.py`)

**Purpose**: Create a minimal reproducible proof-of-concept for the most interesting crash.

**Functionality**:
- Takes a representative crash from the most common crash group
- Determines the minimal buffer size needed to trigger the crash
- Creates a standalone Python script that reproduces the crash
- Validates that the synthetic payload reproduces the same crash

**Usage**:
```bash
python3 poc.py --target ./target_binary --triage-json crash_triage.json
```

**Advanced Options**:
- `--start-size`: Initial payload size to try
- `--max-size`: Maximum payload size to test
- `--pattern`: Use a cyclic pattern instead of 'A's for precise offset determination
- `--frame`: Target a specific crash frame from the triage output

### 4. Crash Summary

**Purpose**: Generate human-readable documentation of findings.

**Content**:
- List of unique crash frames
- Representative input filenames
- Byte offsets used in PoC
- Crash statistics and categorization

## Running the Complete Pipeline

Use the orchestration script to run the entire pipeline in sequence:

```bash
./pipeline.sh [target_binary]
```

This will:
1. Minimize the crash corpus
2. Triage crashes into groups
3. Generate a PoC for the most common crash
4. Create a summary document
5. Test the PoC to verify it works

## Next Steps After Pipeline

1. Use the PoC stub as a starting point for a more sophisticated exploit
2. Analyze the crash frames to understand root causes
3. Develop patches to fix the vulnerabilities
4. Integrate the pipeline into CI/CD for regression testing

## Example Output

The pipeline produces:

1. `crash_triage.json` - Machine-readable crash data
2. `poc.py` - Executable proof-of-concept script
3. `crash_summary.md` - Human-readable documentation

---


